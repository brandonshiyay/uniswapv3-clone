{"ast":null,"code":"module.exports = nba;\nvar NodeHeap = require('../NodeHeap');\nvar heuristics = require('../heuristics');\nvar defaultSettings = require('../defaultSettings.js');\nvar makeNBASearchStatePool = require('./makeNBASearchStatePool.js');\nvar NO_PATH = defaultSettings.NO_PATH;\nmodule.exports.l2 = heuristics.l2;\nmodule.exports.l1 = heuristics.l1;\n\n/**\n * Creates a new instance of pathfinder. A pathfinder has just one method:\n * `find(fromId, toId)`.\n * \n * This is implementation of the NBA* algorithm described in \n * \n *  \"Yet another bidirectional algorithm for shortest paths\" paper by Wim Pijls and Henk Post\n * \n * The paper is available here: https://repub.eur.nl/pub/16100/ei2009-10.pdf\n * \n * @param {ngraph.graph} graph instance. See https://github.com/anvaka/ngraph.graph\n * @param {Object} options that configures search\n * @param {Function(a, b)} options.heuristic - a function that returns estimated distance between\n * nodes `a` and `b`. This function should never overestimate actual distance between two\n * nodes (otherwise the found path will not be the shortest). Defaults function returns 0,\n * which makes this search equivalent to Dijkstra search.\n * @param {Function(a, b)} options.distance - a function that returns actual distance between two\n * nodes `a` and `b`. By default this is set to return graph-theoretical distance (always 1);\n * \n * @returns {Object} A pathfinder with single method `find()`.\n */\nfunction nba(graph, options) {\n  options = options || {};\n  // whether traversal should be considered over oriented graph.\n  var oriented = options.oriented;\n  var quitFast = options.quitFast;\n  var heuristic = options.heuristic;\n  if (!heuristic) heuristic = defaultSettings.heuristic;\n  var distance = options.distance;\n  if (!distance) distance = defaultSettings.distance;\n\n  // During stress tests I noticed that garbage collection was one of the heaviest\n  // contributors to the algorithm's speed. So I'm using an object pool to recycle nodes.\n  var pool = makeNBASearchStatePool();\n  return {\n    /**\n     * Finds a path between node `fromId` and `toId`.\n     * @returns {Array} of nodes between `toId` and `fromId`. Empty array is returned\n     * if no path is found.\n     */\n    find: find\n  };\n  function find(fromId, toId) {\n    // I must apologize for the code duplication. This was the easiest way for me to\n    // implement the algorithm fast.\n    var from = graph.getNode(fromId);\n    if (!from) throw new Error('fromId is not defined in this graph: ' + fromId);\n    var to = graph.getNode(toId);\n    if (!to) throw new Error('toId is not defined in this graph: ' + toId);\n    pool.reset();\n\n    // I must also apologize for somewhat cryptic names. The NBA* is bi-directional\n    // search algorithm, which means it runs two searches in parallel. One is called\n    // forward search and it runs from source node to target, while the other one\n    // (backward search) runs from target to source.\n\n    // Everywhere where you see `1` it means it's for the forward search. `2` is for \n    // backward search.\n\n    // For oriented graph path finding, we need to reverse the graph, so that\n    // backward search visits correct link. Obviously we don't want to duplicate\n    // the graph, instead we always traverse the graph as non-oriented, and filter\n    // edges in `visitN1Oriented/visitN2Oritented`\n    var forwardVisitor = oriented ? visitN1Oriented : visitN1;\n    var reverseVisitor = oriented ? visitN2Oriented : visitN2;\n\n    // Maps nodeId to NBASearchState.\n    var nodeState = new Map();\n\n    // These two heaps store nodes by their underestimated values.\n    var open1Set = new NodeHeap({\n      compare: defaultSettings.compareF1Score,\n      setNodeId: defaultSettings.setH1\n    });\n    var open2Set = new NodeHeap({\n      compare: defaultSettings.compareF2Score,\n      setNodeId: defaultSettings.setH2\n    });\n\n    // This is where both searches will meet.\n    var minNode;\n\n    // The smallest path length seen so far is stored here:\n    var lMin = Number.POSITIVE_INFINITY;\n\n    // We start by putting start/end nodes to the corresponding heaps\n    // If variable names like `f1`, `g1` are too confusing, please refer\n    // to makeNBASearchStatePool.js file, which has detailed description.\n    var startNode = pool.createNewState(from);\n    nodeState.set(fromId, startNode);\n    startNode.g1 = 0;\n    var f1 = heuristic(from, to);\n    startNode.f1 = f1;\n    open1Set.push(startNode);\n    var endNode = pool.createNewState(to);\n    nodeState.set(toId, endNode);\n    endNode.g2 = 0;\n    var f2 = f1; // they should agree originally\n    endNode.f2 = f2;\n    open2Set.push(endNode);\n\n    // the `cameFrom` variable is accessed by both searches, so that we can store parents.\n    var cameFrom;\n\n    // this is the main algorithm loop:\n    while (open2Set.length && open1Set.length) {\n      if (open1Set.length < open2Set.length) {\n        forwardSearch();\n      } else {\n        reverseSearch();\n      }\n      if (quitFast && minNode) break;\n    }\n    var path = reconstructPath(minNode);\n    return path; // the public API is over\n\n    function forwardSearch() {\n      cameFrom = open1Set.pop();\n      if (cameFrom.closed) {\n        return;\n      }\n      cameFrom.closed = true;\n      if (cameFrom.f1 < lMin && cameFrom.g1 + f2 - heuristic(from, cameFrom.node) < lMin) {\n        graph.forEachLinkedNode(cameFrom.node.id, forwardVisitor);\n      }\n      if (open1Set.length > 0) {\n        // this will be used in reverse search\n        f1 = open1Set.peek().f1;\n      }\n    }\n    function reverseSearch() {\n      cameFrom = open2Set.pop();\n      if (cameFrom.closed) {\n        return;\n      }\n      cameFrom.closed = true;\n      if (cameFrom.f2 < lMin && cameFrom.g2 + f1 - heuristic(cameFrom.node, to) < lMin) {\n        graph.forEachLinkedNode(cameFrom.node.id, reverseVisitor);\n      }\n      if (open2Set.length > 0) {\n        // this will be used in forward search\n        f2 = open2Set.peek().f2;\n      }\n    }\n    function visitN1(otherNode, link) {\n      var otherSearchState = nodeState.get(otherNode.id);\n      if (!otherSearchState) {\n        otherSearchState = pool.createNewState(otherNode);\n        nodeState.set(otherNode.id, otherSearchState);\n      }\n      if (otherSearchState.closed) return;\n      var tentativeDistance = cameFrom.g1 + distance(cameFrom.node, otherNode, link);\n      if (tentativeDistance < otherSearchState.g1) {\n        otherSearchState.g1 = tentativeDistance;\n        otherSearchState.f1 = tentativeDistance + heuristic(otherSearchState.node, to);\n        otherSearchState.p1 = cameFrom;\n        if (otherSearchState.h1 < 0) {\n          open1Set.push(otherSearchState);\n        } else {\n          open1Set.updateItem(otherSearchState.h1);\n        }\n      }\n      var potentialMin = otherSearchState.g1 + otherSearchState.g2;\n      if (potentialMin < lMin) {\n        lMin = potentialMin;\n        minNode = otherSearchState;\n      }\n    }\n    function visitN2(otherNode, link) {\n      var otherSearchState = nodeState.get(otherNode.id);\n      if (!otherSearchState) {\n        otherSearchState = pool.createNewState(otherNode);\n        nodeState.set(otherNode.id, otherSearchState);\n      }\n      if (otherSearchState.closed) return;\n      var tentativeDistance = cameFrom.g2 + distance(cameFrom.node, otherNode, link);\n      if (tentativeDistance < otherSearchState.g2) {\n        otherSearchState.g2 = tentativeDistance;\n        otherSearchState.f2 = tentativeDistance + heuristic(from, otherSearchState.node);\n        otherSearchState.p2 = cameFrom;\n        if (otherSearchState.h2 < 0) {\n          open2Set.push(otherSearchState);\n        } else {\n          open2Set.updateItem(otherSearchState.h2);\n        }\n      }\n      var potentialMin = otherSearchState.g1 + otherSearchState.g2;\n      if (potentialMin < lMin) {\n        lMin = potentialMin;\n        minNode = otherSearchState;\n      }\n    }\n    function visitN2Oriented(otherNode, link) {\n      // we are going backwards, graph needs to be reversed. \n      if (link.toId === cameFrom.node.id) return visitN2(otherNode, link);\n    }\n    function visitN1Oriented(otherNode, link) {\n      // this is forward direction, so we should be coming FROM:\n      if (link.fromId === cameFrom.node.id) return visitN1(otherNode, link);\n    }\n  }\n}\nfunction reconstructPath(searchState) {\n  if (!searchState) return NO_PATH;\n  var path = [searchState.node];\n  var parent = searchState.p1;\n  while (parent) {\n    path.push(parent.node);\n    parent = parent.p1;\n  }\n  var child = searchState.p2;\n  while (child) {\n    path.unshift(child.node);\n    child = child.p2;\n  }\n  return path;\n}","map":{"version":3,"names":["module","exports","nba","NodeHeap","require","heuristics","defaultSettings","makeNBASearchStatePool","NO_PATH","l2","l1","graph","options","oriented","quitFast","heuristic","distance","pool","find","fromId","toId","from","getNode","Error","to","reset","forwardVisitor","visitN1Oriented","visitN1","reverseVisitor","visitN2Oriented","visitN2","nodeState","Map","open1Set","compare","compareF1Score","setNodeId","setH1","open2Set","compareF2Score","setH2","minNode","lMin","Number","POSITIVE_INFINITY","startNode","createNewState","set","g1","f1","push","endNode","g2","f2","cameFrom","length","forwardSearch","reverseSearch","path","reconstructPath","pop","closed","node","forEachLinkedNode","id","peek","otherNode","link","otherSearchState","get","tentativeDistance","p1","h1","updateItem","potentialMin","p2","h2","searchState","parent","child","unshift"],"sources":["/home/brandon/security/learning/defi/uniswapv3-src/uniswapv3-code/ui/node_modules/ngraph.path/a-star/nba/index.js"],"sourcesContent":["module.exports = nba;\n\nvar NodeHeap = require('../NodeHeap');\nvar heuristics = require('../heuristics');\nvar defaultSettings = require('../defaultSettings.js');\nvar makeNBASearchStatePool = require('./makeNBASearchStatePool.js');\n\nvar NO_PATH = defaultSettings.NO_PATH;\n\nmodule.exports.l2 = heuristics.l2;\nmodule.exports.l1 = heuristics.l1;\n\n/**\n * Creates a new instance of pathfinder. A pathfinder has just one method:\n * `find(fromId, toId)`.\n * \n * This is implementation of the NBA* algorithm described in \n * \n *  \"Yet another bidirectional algorithm for shortest paths\" paper by Wim Pijls and Henk Post\n * \n * The paper is available here: https://repub.eur.nl/pub/16100/ei2009-10.pdf\n * \n * @param {ngraph.graph} graph instance. See https://github.com/anvaka/ngraph.graph\n * @param {Object} options that configures search\n * @param {Function(a, b)} options.heuristic - a function that returns estimated distance between\n * nodes `a` and `b`. This function should never overestimate actual distance between two\n * nodes (otherwise the found path will not be the shortest). Defaults function returns 0,\n * which makes this search equivalent to Dijkstra search.\n * @param {Function(a, b)} options.distance - a function that returns actual distance between two\n * nodes `a` and `b`. By default this is set to return graph-theoretical distance (always 1);\n * \n * @returns {Object} A pathfinder with single method `find()`.\n */\nfunction nba(graph, options) {\n  options = options || {};\n  // whether traversal should be considered over oriented graph.\n  var oriented = options.oriented;\n  var quitFast = options.quitFast;\n\n  var heuristic = options.heuristic;\n  if (!heuristic) heuristic = defaultSettings.heuristic;\n\n  var distance = options.distance;\n  if (!distance) distance = defaultSettings.distance;\n\n  // During stress tests I noticed that garbage collection was one of the heaviest\n  // contributors to the algorithm's speed. So I'm using an object pool to recycle nodes.\n  var pool = makeNBASearchStatePool();\n\n  return {\n    /**\n     * Finds a path between node `fromId` and `toId`.\n     * @returns {Array} of nodes between `toId` and `fromId`. Empty array is returned\n     * if no path is found.\n     */\n    find: find\n  };\n\n  function find(fromId, toId) {\n    // I must apologize for the code duplication. This was the easiest way for me to\n    // implement the algorithm fast.\n    var from = graph.getNode(fromId);\n    if (!from) throw new Error('fromId is not defined in this graph: ' + fromId);\n    var to = graph.getNode(toId);\n    if (!to) throw new Error('toId is not defined in this graph: ' + toId);\n\n    pool.reset();\n\n    // I must also apologize for somewhat cryptic names. The NBA* is bi-directional\n    // search algorithm, which means it runs two searches in parallel. One is called\n    // forward search and it runs from source node to target, while the other one\n    // (backward search) runs from target to source.\n\n    // Everywhere where you see `1` it means it's for the forward search. `2` is for \n    // backward search.\n\n    // For oriented graph path finding, we need to reverse the graph, so that\n    // backward search visits correct link. Obviously we don't want to duplicate\n    // the graph, instead we always traverse the graph as non-oriented, and filter\n    // edges in `visitN1Oriented/visitN2Oritented`\n    var forwardVisitor = oriented ? visitN1Oriented : visitN1;\n    var reverseVisitor = oriented ? visitN2Oriented : visitN2;\n\n    // Maps nodeId to NBASearchState.\n    var nodeState = new Map();\n\n    // These two heaps store nodes by their underestimated values.\n    var open1Set = new NodeHeap({\n      compare: defaultSettings.compareF1Score,\n      setNodeId: defaultSettings.setH1\n    });\n    var open2Set = new NodeHeap({\n      compare: defaultSettings.compareF2Score,\n      setNodeId: defaultSettings.setH2\n    });\n\n    // This is where both searches will meet.\n    var minNode;\n\n    // The smallest path length seen so far is stored here:\n    var lMin = Number.POSITIVE_INFINITY;\n\n    // We start by putting start/end nodes to the corresponding heaps\n    // If variable names like `f1`, `g1` are too confusing, please refer\n    // to makeNBASearchStatePool.js file, which has detailed description.\n    var startNode = pool.createNewState(from);\n    nodeState.set(fromId, startNode); \n    startNode.g1 = 0;\n    var f1 = heuristic(from, to);\n    startNode.f1 = f1;\n    open1Set.push(startNode);\n\n    var endNode = pool.createNewState(to);\n    nodeState.set(toId, endNode);\n    endNode.g2 = 0;\n    var f2 = f1; // they should agree originally\n    endNode.f2 = f2;\n    open2Set.push(endNode)\n\n    // the `cameFrom` variable is accessed by both searches, so that we can store parents.\n    var cameFrom;\n\n    // this is the main algorithm loop:\n    while (open2Set.length && open1Set.length) {\n      if (open1Set.length < open2Set.length) {\n        forwardSearch();\n      } else {\n        reverseSearch();\n      }\n\n      if (quitFast && minNode) break;\n    }\n\n    var path = reconstructPath(minNode);\n    return path; // the public API is over\n\n    function forwardSearch() {\n      cameFrom = open1Set.pop();\n      if (cameFrom.closed) {\n        return;\n      }\n\n      cameFrom.closed = true;\n\n      if (cameFrom.f1 < lMin && (cameFrom.g1 + f2 - heuristic(from, cameFrom.node)) < lMin) {\n        graph.forEachLinkedNode(cameFrom.node.id, forwardVisitor);\n      }\n\n      if (open1Set.length > 0) {\n        // this will be used in reverse search\n        f1 = open1Set.peek().f1;\n      } \n    }\n\n    function reverseSearch() {\n      cameFrom = open2Set.pop();\n      if (cameFrom.closed) {\n        return;\n      }\n      cameFrom.closed = true;\n\n      if (cameFrom.f2 < lMin && (cameFrom.g2 + f1 - heuristic(cameFrom.node, to)) < lMin) {\n        graph.forEachLinkedNode(cameFrom.node.id, reverseVisitor);\n      }\n\n      if (open2Set.length > 0) {\n        // this will be used in forward search\n        f2 = open2Set.peek().f2;\n      }\n    }\n\n    function visitN1(otherNode, link) {\n      var otherSearchState = nodeState.get(otherNode.id);\n      if (!otherSearchState) {\n        otherSearchState = pool.createNewState(otherNode);\n        nodeState.set(otherNode.id, otherSearchState);\n      }\n\n      if (otherSearchState.closed) return;\n\n      var tentativeDistance = cameFrom.g1 + distance(cameFrom.node, otherNode, link);\n\n      if (tentativeDistance < otherSearchState.g1) {\n        otherSearchState.g1 = tentativeDistance;\n        otherSearchState.f1 = tentativeDistance + heuristic(otherSearchState.node, to);\n        otherSearchState.p1 = cameFrom;\n        if (otherSearchState.h1 < 0) {\n          open1Set.push(otherSearchState);\n        } else {\n          open1Set.updateItem(otherSearchState.h1);\n        }\n      }\n      var potentialMin = otherSearchState.g1 + otherSearchState.g2;\n      if (potentialMin < lMin) { \n        lMin = potentialMin;\n        minNode = otherSearchState;\n      }\n    }\n\n    function visitN2(otherNode, link) {\n      var otherSearchState = nodeState.get(otherNode.id);\n      if (!otherSearchState) {\n        otherSearchState = pool.createNewState(otherNode);\n        nodeState.set(otherNode.id, otherSearchState);\n      }\n\n      if (otherSearchState.closed) return;\n\n      var tentativeDistance = cameFrom.g2 + distance(cameFrom.node, otherNode, link);\n\n      if (tentativeDistance < otherSearchState.g2) {\n        otherSearchState.g2 = tentativeDistance;\n        otherSearchState.f2 = tentativeDistance + heuristic(from, otherSearchState.node);\n        otherSearchState.p2 = cameFrom;\n        if (otherSearchState.h2 < 0) {\n          open2Set.push(otherSearchState);\n        } else {\n          open2Set.updateItem(otherSearchState.h2);\n        }\n      }\n      var potentialMin = otherSearchState.g1 + otherSearchState.g2;\n      if (potentialMin < lMin) {\n        lMin = potentialMin;\n        minNode = otherSearchState;\n      }\n    }\n\n    function visitN2Oriented(otherNode, link) {\n      // we are going backwards, graph needs to be reversed. \n      if (link.toId === cameFrom.node.id) return visitN2(otherNode, link);\n    }\n    function visitN1Oriented(otherNode, link) {\n      // this is forward direction, so we should be coming FROM:\n      if (link.fromId === cameFrom.node.id) return visitN1(otherNode, link);\n    }\n  }\n}\n\nfunction reconstructPath(searchState) {\n  if (!searchState) return NO_PATH;\n\n  var path = [searchState.node];\n  var parent = searchState.p1;\n\n  while (parent) {\n    path.push(parent.node);\n    parent = parent.p1;\n  }\n\n  var child = searchState.p2;\n\n  while (child) {\n    path.unshift(child.node);\n    child = child.p2;\n  }\n  return path;\n}\n"],"mappings":"AAAAA,MAAM,CAACC,OAAO,GAAGC,GAAG;AAEpB,IAAIC,QAAQ,GAAGC,OAAO,CAAC,aAAa,CAAC;AACrC,IAAIC,UAAU,GAAGD,OAAO,CAAC,eAAe,CAAC;AACzC,IAAIE,eAAe,GAAGF,OAAO,CAAC,uBAAuB,CAAC;AACtD,IAAIG,sBAAsB,GAAGH,OAAO,CAAC,6BAA6B,CAAC;AAEnE,IAAII,OAAO,GAAGF,eAAe,CAACE,OAAO;AAErCR,MAAM,CAACC,OAAO,CAACQ,EAAE,GAAGJ,UAAU,CAACI,EAAE;AACjCT,MAAM,CAACC,OAAO,CAACS,EAAE,GAAGL,UAAU,CAACK,EAAE;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASR,GAAGA,CAACS,KAAK,EAAEC,OAAO,EAAE;EAC3BA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB;EACA,IAAIC,QAAQ,GAAGD,OAAO,CAACC,QAAQ;EAC/B,IAAIC,QAAQ,GAAGF,OAAO,CAACE,QAAQ;EAE/B,IAAIC,SAAS,GAAGH,OAAO,CAACG,SAAS;EACjC,IAAI,CAACA,SAAS,EAAEA,SAAS,GAAGT,eAAe,CAACS,SAAS;EAErD,IAAIC,QAAQ,GAAGJ,OAAO,CAACI,QAAQ;EAC/B,IAAI,CAACA,QAAQ,EAAEA,QAAQ,GAAGV,eAAe,CAACU,QAAQ;;EAElD;EACA;EACA,IAAIC,IAAI,GAAGV,sBAAsB,EAAE;EAEnC,OAAO;IACL;AACJ;AACA;AACA;AACA;IACIW,IAAI,EAAEA;EACR,CAAC;EAED,SAASA,IAAIA,CAACC,MAAM,EAAEC,IAAI,EAAE;IAC1B;IACA;IACA,IAAIC,IAAI,GAAGV,KAAK,CAACW,OAAO,CAACH,MAAM,CAAC;IAChC,IAAI,CAACE,IAAI,EAAE,MAAM,IAAIE,KAAK,CAAC,uCAAuC,GAAGJ,MAAM,CAAC;IAC5E,IAAIK,EAAE,GAAGb,KAAK,CAACW,OAAO,CAACF,IAAI,CAAC;IAC5B,IAAI,CAACI,EAAE,EAAE,MAAM,IAAID,KAAK,CAAC,qCAAqC,GAAGH,IAAI,CAAC;IAEtEH,IAAI,CAACQ,KAAK,EAAE;;IAEZ;IACA;IACA;IACA;;IAEA;IACA;;IAEA;IACA;IACA;IACA;IACA,IAAIC,cAAc,GAAGb,QAAQ,GAAGc,eAAe,GAAGC,OAAO;IACzD,IAAIC,cAAc,GAAGhB,QAAQ,GAAGiB,eAAe,GAAGC,OAAO;;IAEzD;IACA,IAAIC,SAAS,GAAG,IAAIC,GAAG,EAAE;;IAEzB;IACA,IAAIC,QAAQ,GAAG,IAAI/B,QAAQ,CAAC;MAC1BgC,OAAO,EAAE7B,eAAe,CAAC8B,cAAc;MACvCC,SAAS,EAAE/B,eAAe,CAACgC;IAC7B,CAAC,CAAC;IACF,IAAIC,QAAQ,GAAG,IAAIpC,QAAQ,CAAC;MAC1BgC,OAAO,EAAE7B,eAAe,CAACkC,cAAc;MACvCH,SAAS,EAAE/B,eAAe,CAACmC;IAC7B,CAAC,CAAC;;IAEF;IACA,IAAIC,OAAO;;IAEX;IACA,IAAIC,IAAI,GAAGC,MAAM,CAACC,iBAAiB;;IAEnC;IACA;IACA;IACA,IAAIC,SAAS,GAAG7B,IAAI,CAAC8B,cAAc,CAAC1B,IAAI,CAAC;IACzCW,SAAS,CAACgB,GAAG,CAAC7B,MAAM,EAAE2B,SAAS,CAAC;IAChCA,SAAS,CAACG,EAAE,GAAG,CAAC;IAChB,IAAIC,EAAE,GAAGnC,SAAS,CAACM,IAAI,EAAEG,EAAE,CAAC;IAC5BsB,SAAS,CAACI,EAAE,GAAGA,EAAE;IACjBhB,QAAQ,CAACiB,IAAI,CAACL,SAAS,CAAC;IAExB,IAAIM,OAAO,GAAGnC,IAAI,CAAC8B,cAAc,CAACvB,EAAE,CAAC;IACrCQ,SAAS,CAACgB,GAAG,CAAC5B,IAAI,EAAEgC,OAAO,CAAC;IAC5BA,OAAO,CAACC,EAAE,GAAG,CAAC;IACd,IAAIC,EAAE,GAAGJ,EAAE,CAAC,CAAC;IACbE,OAAO,CAACE,EAAE,GAAGA,EAAE;IACff,QAAQ,CAACY,IAAI,CAACC,OAAO,CAAC;;IAEtB;IACA,IAAIG,QAAQ;;IAEZ;IACA,OAAOhB,QAAQ,CAACiB,MAAM,IAAItB,QAAQ,CAACsB,MAAM,EAAE;MACzC,IAAItB,QAAQ,CAACsB,MAAM,GAAGjB,QAAQ,CAACiB,MAAM,EAAE;QACrCC,aAAa,EAAE;MACjB,CAAC,MAAM;QACLC,aAAa,EAAE;MACjB;MAEA,IAAI5C,QAAQ,IAAI4B,OAAO,EAAE;IAC3B;IAEA,IAAIiB,IAAI,GAAGC,eAAe,CAAClB,OAAO,CAAC;IACnC,OAAOiB,IAAI,CAAC,CAAC;;IAEb,SAASF,aAAaA,CAAA,EAAG;MACvBF,QAAQ,GAAGrB,QAAQ,CAAC2B,GAAG,EAAE;MACzB,IAAIN,QAAQ,CAACO,MAAM,EAAE;QACnB;MACF;MAEAP,QAAQ,CAACO,MAAM,GAAG,IAAI;MAEtB,IAAIP,QAAQ,CAACL,EAAE,GAAGP,IAAI,IAAKY,QAAQ,CAACN,EAAE,GAAGK,EAAE,GAAGvC,SAAS,CAACM,IAAI,EAAEkC,QAAQ,CAACQ,IAAI,CAAC,GAAIpB,IAAI,EAAE;QACpFhC,KAAK,CAACqD,iBAAiB,CAACT,QAAQ,CAACQ,IAAI,CAACE,EAAE,EAAEvC,cAAc,CAAC;MAC3D;MAEA,IAAIQ,QAAQ,CAACsB,MAAM,GAAG,CAAC,EAAE;QACvB;QACAN,EAAE,GAAGhB,QAAQ,CAACgC,IAAI,EAAE,CAAChB,EAAE;MACzB;IACF;IAEA,SAASQ,aAAaA,CAAA,EAAG;MACvBH,QAAQ,GAAGhB,QAAQ,CAACsB,GAAG,EAAE;MACzB,IAAIN,QAAQ,CAACO,MAAM,EAAE;QACnB;MACF;MACAP,QAAQ,CAACO,MAAM,GAAG,IAAI;MAEtB,IAAIP,QAAQ,CAACD,EAAE,GAAGX,IAAI,IAAKY,QAAQ,CAACF,EAAE,GAAGH,EAAE,GAAGnC,SAAS,CAACwC,QAAQ,CAACQ,IAAI,EAAEvC,EAAE,CAAC,GAAImB,IAAI,EAAE;QAClFhC,KAAK,CAACqD,iBAAiB,CAACT,QAAQ,CAACQ,IAAI,CAACE,EAAE,EAAEpC,cAAc,CAAC;MAC3D;MAEA,IAAIU,QAAQ,CAACiB,MAAM,GAAG,CAAC,EAAE;QACvB;QACAF,EAAE,GAAGf,QAAQ,CAAC2B,IAAI,EAAE,CAACZ,EAAE;MACzB;IACF;IAEA,SAAS1B,OAAOA,CAACuC,SAAS,EAAEC,IAAI,EAAE;MAChC,IAAIC,gBAAgB,GAAGrC,SAAS,CAACsC,GAAG,CAACH,SAAS,CAACF,EAAE,CAAC;MAClD,IAAI,CAACI,gBAAgB,EAAE;QACrBA,gBAAgB,GAAGpD,IAAI,CAAC8B,cAAc,CAACoB,SAAS,CAAC;QACjDnC,SAAS,CAACgB,GAAG,CAACmB,SAAS,CAACF,EAAE,EAAEI,gBAAgB,CAAC;MAC/C;MAEA,IAAIA,gBAAgB,CAACP,MAAM,EAAE;MAE7B,IAAIS,iBAAiB,GAAGhB,QAAQ,CAACN,EAAE,GAAGjC,QAAQ,CAACuC,QAAQ,CAACQ,IAAI,EAAEI,SAAS,EAAEC,IAAI,CAAC;MAE9E,IAAIG,iBAAiB,GAAGF,gBAAgB,CAACpB,EAAE,EAAE;QAC3CoB,gBAAgB,CAACpB,EAAE,GAAGsB,iBAAiB;QACvCF,gBAAgB,CAACnB,EAAE,GAAGqB,iBAAiB,GAAGxD,SAAS,CAACsD,gBAAgB,CAACN,IAAI,EAAEvC,EAAE,CAAC;QAC9E6C,gBAAgB,CAACG,EAAE,GAAGjB,QAAQ;QAC9B,IAAIc,gBAAgB,CAACI,EAAE,GAAG,CAAC,EAAE;UAC3BvC,QAAQ,CAACiB,IAAI,CAACkB,gBAAgB,CAAC;QACjC,CAAC,MAAM;UACLnC,QAAQ,CAACwC,UAAU,CAACL,gBAAgB,CAACI,EAAE,CAAC;QAC1C;MACF;MACA,IAAIE,YAAY,GAAGN,gBAAgB,CAACpB,EAAE,GAAGoB,gBAAgB,CAAChB,EAAE;MAC5D,IAAIsB,YAAY,GAAGhC,IAAI,EAAE;QACvBA,IAAI,GAAGgC,YAAY;QACnBjC,OAAO,GAAG2B,gBAAgB;MAC5B;IACF;IAEA,SAAStC,OAAOA,CAACoC,SAAS,EAAEC,IAAI,EAAE;MAChC,IAAIC,gBAAgB,GAAGrC,SAAS,CAACsC,GAAG,CAACH,SAAS,CAACF,EAAE,CAAC;MAClD,IAAI,CAACI,gBAAgB,EAAE;QACrBA,gBAAgB,GAAGpD,IAAI,CAAC8B,cAAc,CAACoB,SAAS,CAAC;QACjDnC,SAAS,CAACgB,GAAG,CAACmB,SAAS,CAACF,EAAE,EAAEI,gBAAgB,CAAC;MAC/C;MAEA,IAAIA,gBAAgB,CAACP,MAAM,EAAE;MAE7B,IAAIS,iBAAiB,GAAGhB,QAAQ,CAACF,EAAE,GAAGrC,QAAQ,CAACuC,QAAQ,CAACQ,IAAI,EAAEI,SAAS,EAAEC,IAAI,CAAC;MAE9E,IAAIG,iBAAiB,GAAGF,gBAAgB,CAAChB,EAAE,EAAE;QAC3CgB,gBAAgB,CAAChB,EAAE,GAAGkB,iBAAiB;QACvCF,gBAAgB,CAACf,EAAE,GAAGiB,iBAAiB,GAAGxD,SAAS,CAACM,IAAI,EAAEgD,gBAAgB,CAACN,IAAI,CAAC;QAChFM,gBAAgB,CAACO,EAAE,GAAGrB,QAAQ;QAC9B,IAAIc,gBAAgB,CAACQ,EAAE,GAAG,CAAC,EAAE;UAC3BtC,QAAQ,CAACY,IAAI,CAACkB,gBAAgB,CAAC;QACjC,CAAC,MAAM;UACL9B,QAAQ,CAACmC,UAAU,CAACL,gBAAgB,CAACQ,EAAE,CAAC;QAC1C;MACF;MACA,IAAIF,YAAY,GAAGN,gBAAgB,CAACpB,EAAE,GAAGoB,gBAAgB,CAAChB,EAAE;MAC5D,IAAIsB,YAAY,GAAGhC,IAAI,EAAE;QACvBA,IAAI,GAAGgC,YAAY;QACnBjC,OAAO,GAAG2B,gBAAgB;MAC5B;IACF;IAEA,SAASvC,eAAeA,CAACqC,SAAS,EAAEC,IAAI,EAAE;MACxC;MACA,IAAIA,IAAI,CAAChD,IAAI,KAAKmC,QAAQ,CAACQ,IAAI,CAACE,EAAE,EAAE,OAAOlC,OAAO,CAACoC,SAAS,EAAEC,IAAI,CAAC;IACrE;IACA,SAASzC,eAAeA,CAACwC,SAAS,EAAEC,IAAI,EAAE;MACxC;MACA,IAAIA,IAAI,CAACjD,MAAM,KAAKoC,QAAQ,CAACQ,IAAI,CAACE,EAAE,EAAE,OAAOrC,OAAO,CAACuC,SAAS,EAAEC,IAAI,CAAC;IACvE;EACF;AACF;AAEA,SAASR,eAAeA,CAACkB,WAAW,EAAE;EACpC,IAAI,CAACA,WAAW,EAAE,OAAOtE,OAAO;EAEhC,IAAImD,IAAI,GAAG,CAACmB,WAAW,CAACf,IAAI,CAAC;EAC7B,IAAIgB,MAAM,GAAGD,WAAW,CAACN,EAAE;EAE3B,OAAOO,MAAM,EAAE;IACbpB,IAAI,CAACR,IAAI,CAAC4B,MAAM,CAAChB,IAAI,CAAC;IACtBgB,MAAM,GAAGA,MAAM,CAACP,EAAE;EACpB;EAEA,IAAIQ,KAAK,GAAGF,WAAW,CAACF,EAAE;EAE1B,OAAOI,KAAK,EAAE;IACZrB,IAAI,CAACsB,OAAO,CAACD,KAAK,CAACjB,IAAI,CAAC;IACxBiB,KAAK,GAAGA,KAAK,CAACJ,EAAE;EAClB;EACA,OAAOjB,IAAI;AACb"},"metadata":{},"sourceType":"script","externalDependencies":[]}