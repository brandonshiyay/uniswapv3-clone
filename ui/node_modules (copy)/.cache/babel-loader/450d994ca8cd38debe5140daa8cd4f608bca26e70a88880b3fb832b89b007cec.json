{"ast":null,"code":"module.exports = makeNBASearchStatePool;\n\n/**\n * Creates new instance of NBASearchState. The instance stores information\n * about search state, and is used by NBA* algorithm.\n *\n * @param {Object} node - original graph node\n */\nfunction NBASearchState(node) {\n  /**\n   * Original graph node.\n   */\n  this.node = node;\n\n  /**\n   * Parent of this node in forward search\n   */\n  this.p1 = null;\n\n  /**\n   * Parent of this node in reverse search\n   */\n  this.p2 = null;\n\n  /**\n   * If this is set to true, then the node was already processed\n   * and we should not touch it anymore.\n   */\n  this.closed = false;\n\n  /**\n   * Actual distance from this node to its parent in forward search\n   */\n  this.g1 = Number.POSITIVE_INFINITY;\n\n  /**\n   * Actual distance from this node to its parent in reverse search\n   */\n  this.g2 = Number.POSITIVE_INFINITY;\n\n  /**\n   * Underestimated distance from this node to the path-finding source.\n   */\n  this.f1 = Number.POSITIVE_INFINITY;\n\n  /**\n   * Underestimated distance from this node to the path-finding target.\n   */\n  this.f2 = Number.POSITIVE_INFINITY;\n\n  // used to reconstruct heap when fScore is updated. TODO: do I need them both?\n\n  /**\n   * Index of this node in the forward heap.\n   */\n  this.h1 = -1;\n\n  /**\n   * Index of this node in the reverse heap.\n   */\n  this.h2 = -1;\n}\n\n/**\n * As path-finding is memory-intensive process, we want to reduce pressure on\n * garbage collector. This class helps us to recycle path-finding nodes and significantly\n * reduces the search time (~20% faster than without it).\n */\nfunction makeNBASearchStatePool() {\n  var currentInCache = 0;\n  var nodeCache = [];\n  return {\n    /**\n     * Creates a new NBASearchState instance\n     */\n    createNewState: createNewState,\n    /**\n     * Marks all created instances available for recycling.\n     */\n    reset: reset\n  };\n  function reset() {\n    currentInCache = 0;\n  }\n  function createNewState(node) {\n    var cached = nodeCache[currentInCache];\n    if (cached) {\n      // TODO: This almost duplicates constructor code. Not sure if\n      // it would impact performance if I move this code into a function\n      cached.node = node;\n\n      // How we came to this node?\n      cached.p1 = null;\n      cached.p2 = null;\n      cached.closed = false;\n      cached.g1 = Number.POSITIVE_INFINITY;\n      cached.g2 = Number.POSITIVE_INFINITY;\n      cached.f1 = Number.POSITIVE_INFINITY;\n      cached.f2 = Number.POSITIVE_INFINITY;\n\n      // used to reconstruct heap when fScore is updated.\n      cached.h1 = -1;\n      cached.h2 = -1;\n    } else {\n      cached = new NBASearchState(node);\n      nodeCache[currentInCache] = cached;\n    }\n    currentInCache++;\n    return cached;\n  }\n}","map":{"version":3,"names":["module","exports","makeNBASearchStatePool","NBASearchState","node","p1","p2","closed","g1","Number","POSITIVE_INFINITY","g2","f1","f2","h1","h2","currentInCache","nodeCache","createNewState","reset","cached"],"sources":["/home/brandon/security/learning/defi/uniswapv3-src/uniswapv3-code/ui/node_modules/ngraph.path/a-star/nba/makeNBASearchStatePool.js"],"sourcesContent":["module.exports = makeNBASearchStatePool;\n\n/**\n * Creates new instance of NBASearchState. The instance stores information\n * about search state, and is used by NBA* algorithm.\n *\n * @param {Object} node - original graph node\n */\nfunction NBASearchState(node) {\n  /**\n   * Original graph node.\n   */\n  this.node = node;\n\n  /**\n   * Parent of this node in forward search\n   */\n  this.p1 = null;\n\n  /**\n   * Parent of this node in reverse search\n   */\n  this.p2 = null;\n\n  /**\n   * If this is set to true, then the node was already processed\n   * and we should not touch it anymore.\n   */\n  this.closed = false;\n\n  /**\n   * Actual distance from this node to its parent in forward search\n   */\n  this.g1 = Number.POSITIVE_INFINITY;\n\n  /**\n   * Actual distance from this node to its parent in reverse search\n   */\n  this.g2 = Number.POSITIVE_INFINITY;\n\n\n  /**\n   * Underestimated distance from this node to the path-finding source.\n   */\n  this.f1 = Number.POSITIVE_INFINITY;\n\n  /**\n   * Underestimated distance from this node to the path-finding target.\n   */\n  this.f2 = Number.POSITIVE_INFINITY;\n\n  // used to reconstruct heap when fScore is updated. TODO: do I need them both?\n\n  /**\n   * Index of this node in the forward heap.\n   */\n  this.h1 = -1;\n\n  /**\n   * Index of this node in the reverse heap.\n   */\n  this.h2 = -1;\n}\n\n/**\n * As path-finding is memory-intensive process, we want to reduce pressure on\n * garbage collector. This class helps us to recycle path-finding nodes and significantly\n * reduces the search time (~20% faster than without it).\n */\nfunction makeNBASearchStatePool() {\n  var currentInCache = 0;\n  var nodeCache = [];\n\n  return {\n    /**\n     * Creates a new NBASearchState instance\n     */\n    createNewState: createNewState,\n\n    /**\n     * Marks all created instances available for recycling.\n     */\n    reset: reset\n  };\n\n  function reset() {\n    currentInCache = 0;\n  }\n\n  function createNewState(node) {\n    var cached = nodeCache[currentInCache];\n    if (cached) {\n      // TODO: This almost duplicates constructor code. Not sure if\n      // it would impact performance if I move this code into a function\n      cached.node = node;\n\n      // How we came to this node?\n      cached.p1 = null;\n      cached.p2 = null;\n\n      cached.closed = false;\n\n      cached.g1 = Number.POSITIVE_INFINITY;\n      cached.g2 = Number.POSITIVE_INFINITY;\n      cached.f1 = Number.POSITIVE_INFINITY;\n      cached.f2 = Number.POSITIVE_INFINITY;\n\n      // used to reconstruct heap when fScore is updated.\n      cached.h1 = -1;\n      cached.h2 = -1;\n    } else {\n      cached = new NBASearchState(node);\n      nodeCache[currentInCache] = cached;\n    }\n    currentInCache++;\n    return cached;\n  }\n}\n"],"mappings":"AAAAA,MAAM,CAACC,OAAO,GAAGC,sBAAsB;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAACC,IAAI,EAAE;EAC5B;AACF;AACA;EACE,IAAI,CAACA,IAAI,GAAGA,IAAI;;EAEhB;AACF;AACA;EACE,IAAI,CAACC,EAAE,GAAG,IAAI;;EAEd;AACF;AACA;EACE,IAAI,CAACC,EAAE,GAAG,IAAI;;EAEd;AACF;AACA;AACA;EACE,IAAI,CAACC,MAAM,GAAG,KAAK;;EAEnB;AACF;AACA;EACE,IAAI,CAACC,EAAE,GAAGC,MAAM,CAACC,iBAAiB;;EAElC;AACF;AACA;EACE,IAAI,CAACC,EAAE,GAAGF,MAAM,CAACC,iBAAiB;;EAGlC;AACF;AACA;EACE,IAAI,CAACE,EAAE,GAAGH,MAAM,CAACC,iBAAiB;;EAElC;AACF;AACA;EACE,IAAI,CAACG,EAAE,GAAGJ,MAAM,CAACC,iBAAiB;;EAElC;;EAEA;AACF;AACA;EACE,IAAI,CAACI,EAAE,GAAG,CAAC,CAAC;;EAEZ;AACF;AACA;EACE,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASb,sBAAsBA,CAAA,EAAG;EAChC,IAAIc,cAAc,GAAG,CAAC;EACtB,IAAIC,SAAS,GAAG,EAAE;EAElB,OAAO;IACL;AACJ;AACA;IACIC,cAAc,EAAEA,cAAc;IAE9B;AACJ;AACA;IACIC,KAAK,EAAEA;EACT,CAAC;EAED,SAASA,KAAKA,CAAA,EAAG;IACfH,cAAc,GAAG,CAAC;EACpB;EAEA,SAASE,cAAcA,CAACd,IAAI,EAAE;IAC5B,IAAIgB,MAAM,GAAGH,SAAS,CAACD,cAAc,CAAC;IACtC,IAAII,MAAM,EAAE;MACV;MACA;MACAA,MAAM,CAAChB,IAAI,GAAGA,IAAI;;MAElB;MACAgB,MAAM,CAACf,EAAE,GAAG,IAAI;MAChBe,MAAM,CAACd,EAAE,GAAG,IAAI;MAEhBc,MAAM,CAACb,MAAM,GAAG,KAAK;MAErBa,MAAM,CAACZ,EAAE,GAAGC,MAAM,CAACC,iBAAiB;MACpCU,MAAM,CAACT,EAAE,GAAGF,MAAM,CAACC,iBAAiB;MACpCU,MAAM,CAACR,EAAE,GAAGH,MAAM,CAACC,iBAAiB;MACpCU,MAAM,CAACP,EAAE,GAAGJ,MAAM,CAACC,iBAAiB;;MAEpC;MACAU,MAAM,CAACN,EAAE,GAAG,CAAC,CAAC;MACdM,MAAM,CAACL,EAAE,GAAG,CAAC,CAAC;IAChB,CAAC,MAAM;MACLK,MAAM,GAAG,IAAIjB,cAAc,CAACC,IAAI,CAAC;MACjCa,SAAS,CAACD,cAAc,CAAC,GAAGI,MAAM;IACpC;IACAJ,cAAc,EAAE;IAChB,OAAOI,MAAM;EACf;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}