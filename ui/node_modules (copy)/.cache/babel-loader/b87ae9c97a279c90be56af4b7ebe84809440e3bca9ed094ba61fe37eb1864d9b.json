{"ast":null,"code":"/**\n * Performs a uni-directional A Star search on graph.\n * \n * We will try to minimize f(n) = g(n) + h(n), where\n * g(n) is actual distance from source node to `n`, and\n * h(n) is heuristic distance from `n` to target node.\n */\nmodule.exports = aStarPathSearch;\nvar NodeHeap = require('./NodeHeap');\nvar makeSearchStatePool = require('./makeSearchStatePool');\nvar heuristics = require('./heuristics');\nvar defaultSettings = require('./defaultSettings.js');\nvar NO_PATH = defaultSettings.NO_PATH;\nmodule.exports.l2 = heuristics.l2;\nmodule.exports.l1 = heuristics.l1;\n\n/**\n * Creates a new instance of pathfinder. A pathfinder has just one method:\n * `find(fromId, toId)`, it may be extended in future.\n * \n * @param {ngraph.graph} graph instance. See https://github.com/anvaka/ngraph.graph\n * @param {Object} options that configures search\n * @param {Function(a, b)} options.heuristic - a function that returns estimated distance between\n * nodes `a` and `b`. This function should never overestimate actual distance between two\n * nodes (otherwise the found path will not be the shortest). Defaults function returns 0,\n * which makes this search equivalent to Dijkstra search.\n * @param {Function(a, b)} options.distance - a function that returns actual distance between two\n * nodes `a` and `b`. By default this is set to return graph-theoretical distance (always 1);\n * @param {Boolean} options.oriented - whether graph should be considered oriented or not.\n * \n * @returns {Object} A pathfinder with single method `find()`.\n */\nfunction aStarPathSearch(graph, options) {\n  options = options || {};\n  // whether traversal should be considered over oriented graph.\n  var oriented = options.oriented;\n  var heuristic = options.heuristic;\n  if (!heuristic) heuristic = defaultSettings.heuristic;\n  var distance = options.distance;\n  if (!distance) distance = defaultSettings.distance;\n  var pool = makeSearchStatePool();\n  return {\n    /**\n     * Finds a path between node `fromId` and `toId`.\n     * @returns {Array} of nodes between `toId` and `fromId`. Empty array is returned\n     * if no path is found.\n     */\n    find: find\n  };\n  function find(fromId, toId) {\n    var from = graph.getNode(fromId);\n    if (!from) throw new Error('fromId is not defined in this graph: ' + fromId);\n    var to = graph.getNode(toId);\n    if (!to) throw new Error('toId is not defined in this graph: ' + toId);\n    pool.reset();\n\n    // Maps nodeId to NodeSearchState.\n    var nodeState = new Map();\n\n    // the nodes that we still need to evaluate\n    var openSet = new NodeHeap({\n      compare: defaultSettings.compareFScore,\n      setNodeId: defaultSettings.setHeapIndex\n    });\n    var startNode = pool.createNewState(from);\n    nodeState.set(fromId, startNode);\n\n    // For the first node, fScore is completely heuristic.\n    startNode.fScore = heuristic(from, to);\n\n    // The cost of going from start to start is zero.\n    startNode.distanceToSource = 0;\n    openSet.push(startNode);\n    startNode.open = 1;\n    var cameFrom;\n    while (openSet.length > 0) {\n      cameFrom = openSet.pop();\n      if (goalReached(cameFrom, to)) return reconstructPath(cameFrom);\n\n      // no need to visit this node anymore\n      cameFrom.closed = true;\n      graph.forEachLinkedNode(cameFrom.node.id, visitNeighbour, oriented);\n    }\n\n    // If we got here, then there is no path.\n    return NO_PATH;\n    function visitNeighbour(otherNode, link) {\n      var otherSearchState = nodeState.get(otherNode.id);\n      if (!otherSearchState) {\n        otherSearchState = pool.createNewState(otherNode);\n        nodeState.set(otherNode.id, otherSearchState);\n      }\n      if (otherSearchState.closed) {\n        // Already processed this node.\n        return;\n      }\n      if (otherSearchState.open === 0) {\n        // Remember this node.\n        openSet.push(otherSearchState);\n        otherSearchState.open = 1;\n      }\n      var tentativeDistance = cameFrom.distanceToSource + distance(otherNode, cameFrom.node, link);\n      if (tentativeDistance >= otherSearchState.distanceToSource) {\n        // This would only make our path longer. Ignore this route.\n        return;\n      }\n\n      // bingo! we found shorter path:\n      otherSearchState.parent = cameFrom;\n      otherSearchState.distanceToSource = tentativeDistance;\n      otherSearchState.fScore = tentativeDistance + heuristic(otherSearchState.node, to);\n      openSet.updateItem(otherSearchState.heapIndex);\n    }\n  }\n}\nfunction goalReached(searchState, targetNode) {\n  return searchState.node === targetNode;\n}\nfunction reconstructPath(searchState) {\n  var path = [searchState.node];\n  var parent = searchState.parent;\n  while (parent) {\n    path.push(parent.node);\n    parent = parent.parent;\n  }\n  return path;\n}","map":{"version":3,"names":["module","exports","aStarPathSearch","NodeHeap","require","makeSearchStatePool","heuristics","defaultSettings","NO_PATH","l2","l1","graph","options","oriented","heuristic","distance","pool","find","fromId","toId","from","getNode","Error","to","reset","nodeState","Map","openSet","compare","compareFScore","setNodeId","setHeapIndex","startNode","createNewState","set","fScore","distanceToSource","push","open","cameFrom","length","pop","goalReached","reconstructPath","closed","forEachLinkedNode","node","id","visitNeighbour","otherNode","link","otherSearchState","get","tentativeDistance","parent","updateItem","heapIndex","searchState","targetNode","path"],"sources":["/home/brandon/security/learning/defi/uniswapv3-src/uniswapv3-code/ui/node_modules/ngraph.path/a-star/a-star.js"],"sourcesContent":["/**\n * Performs a uni-directional A Star search on graph.\n * \n * We will try to minimize f(n) = g(n) + h(n), where\n * g(n) is actual distance from source node to `n`, and\n * h(n) is heuristic distance from `n` to target node.\n */\nmodule.exports = aStarPathSearch;\n\nvar NodeHeap = require('./NodeHeap');\nvar makeSearchStatePool = require('./makeSearchStatePool');\nvar heuristics = require('./heuristics');\nvar defaultSettings = require('./defaultSettings.js');\n\nvar NO_PATH = defaultSettings.NO_PATH;\n\nmodule.exports.l2 = heuristics.l2;\nmodule.exports.l1 = heuristics.l1;\n\n/**\n * Creates a new instance of pathfinder. A pathfinder has just one method:\n * `find(fromId, toId)`, it may be extended in future.\n * \n * @param {ngraph.graph} graph instance. See https://github.com/anvaka/ngraph.graph\n * @param {Object} options that configures search\n * @param {Function(a, b)} options.heuristic - a function that returns estimated distance between\n * nodes `a` and `b`. This function should never overestimate actual distance between two\n * nodes (otherwise the found path will not be the shortest). Defaults function returns 0,\n * which makes this search equivalent to Dijkstra search.\n * @param {Function(a, b)} options.distance - a function that returns actual distance between two\n * nodes `a` and `b`. By default this is set to return graph-theoretical distance (always 1);\n * @param {Boolean} options.oriented - whether graph should be considered oriented or not.\n * \n * @returns {Object} A pathfinder with single method `find()`.\n */\nfunction aStarPathSearch(graph, options) {\n  options = options || {};\n  // whether traversal should be considered over oriented graph.\n  var oriented = options.oriented;\n\n  var heuristic = options.heuristic;\n  if (!heuristic) heuristic = defaultSettings.heuristic;\n\n  var distance = options.distance;\n  if (!distance) distance = defaultSettings.distance;\n  var pool = makeSearchStatePool();\n\n  return {\n    /**\n     * Finds a path between node `fromId` and `toId`.\n     * @returns {Array} of nodes between `toId` and `fromId`. Empty array is returned\n     * if no path is found.\n     */\n    find: find\n  };\n\n  function find(fromId, toId) {\n    var from = graph.getNode(fromId);\n    if (!from) throw new Error('fromId is not defined in this graph: ' + fromId);\n    var to = graph.getNode(toId);\n    if (!to) throw new Error('toId is not defined in this graph: ' + toId);\n    pool.reset();\n\n    // Maps nodeId to NodeSearchState.\n    var nodeState = new Map();\n\n    // the nodes that we still need to evaluate\n    var openSet = new NodeHeap({\n      compare: defaultSettings.compareFScore,\n      setNodeId: defaultSettings.setHeapIndex\n    });\n\n    var startNode = pool.createNewState(from);\n    nodeState.set(fromId, startNode);\n\n    // For the first node, fScore is completely heuristic.\n    startNode.fScore = heuristic(from, to);\n\n    // The cost of going from start to start is zero.\n    startNode.distanceToSource = 0;\n    openSet.push(startNode);\n    startNode.open = 1;\n\n    var cameFrom;\n\n    while (openSet.length > 0) {\n      cameFrom = openSet.pop();\n      if (goalReached(cameFrom, to)) return reconstructPath(cameFrom);\n\n      // no need to visit this node anymore\n      cameFrom.closed = true;\n      graph.forEachLinkedNode(cameFrom.node.id, visitNeighbour, oriented);\n    }\n\n    // If we got here, then there is no path.\n    return NO_PATH;\n\n    function visitNeighbour(otherNode, link) {\n      var otherSearchState = nodeState.get(otherNode.id);\n      if (!otherSearchState) {\n        otherSearchState = pool.createNewState(otherNode);\n        nodeState.set(otherNode.id, otherSearchState);\n      }\n\n      if (otherSearchState.closed) {\n        // Already processed this node.\n        return;\n      }\n      if (otherSearchState.open === 0) {\n        // Remember this node.\n        openSet.push(otherSearchState);\n        otherSearchState.open = 1;\n      }\n\n      var tentativeDistance = cameFrom.distanceToSource + distance(otherNode, cameFrom.node, link);\n      if (tentativeDistance >= otherSearchState.distanceToSource) {\n        // This would only make our path longer. Ignore this route.\n        return;\n      }\n\n      // bingo! we found shorter path:\n      otherSearchState.parent = cameFrom;\n      otherSearchState.distanceToSource = tentativeDistance;\n      otherSearchState.fScore = tentativeDistance + heuristic(otherSearchState.node, to);\n\n      openSet.updateItem(otherSearchState.heapIndex);\n    }\n  }\n}\n\nfunction goalReached(searchState, targetNode) {\n  return searchState.node === targetNode;\n}\n\nfunction reconstructPath(searchState) {\n  var path = [searchState.node];\n  var parent = searchState.parent;\n\n  while (parent) {\n    path.push(parent.node);\n    parent = parent.parent;\n  }\n\n  return path;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}