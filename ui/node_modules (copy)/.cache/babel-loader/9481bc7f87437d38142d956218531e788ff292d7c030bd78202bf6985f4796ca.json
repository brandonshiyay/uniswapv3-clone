{"ast":null,"code":"/**\n * Performs suboptimal, greed A Star path finding.\n * This finder does not necessary finds the shortest path. The path\n * that it finds is very close to the shortest one. It is very fast though.\n */\nmodule.exports = aStarBi;\nvar NodeHeap = require('./NodeHeap');\nvar makeSearchStatePool = require('./makeSearchStatePool');\nvar heuristics = require('./heuristics');\nvar defaultSettings = require('./defaultSettings');\nvar BY_FROM = 1;\nvar BY_TO = 2;\nvar NO_PATH = defaultSettings.NO_PATH;\nmodule.exports.l2 = heuristics.l2;\nmodule.exports.l1 = heuristics.l1;\n\n/**\n * Creates a new instance of pathfinder. A pathfinder has just one method:\n * `find(fromId, toId)`, it may be extended in future.\n * \n * NOTE: Algorithm implemented in this code DOES NOT find optimal path.\n * Yet the path that it finds is always near optimal, and it finds it very fast.\n * \n * @param {ngraph.graph} graph instance. See https://github.com/anvaka/ngraph.graph\n * \n * @param {Object} options that configures search\n * @param {Function(a, b)} options.heuristic - a function that returns estimated distance between\n * nodes `a` and `b`.  Defaults function returns 0, which makes this search equivalent to Dijkstra search.\n * @param {Function(a, b)} options.distance - a function that returns actual distance between two\n * nodes `a` and `b`. By default this is set to return graph-theoretical distance (always 1);\n * @param {Boolean} options.oriented - whether graph should be considered oriented or not.\n * \n * @returns {Object} A pathfinder with single method `find()`.\n */\nfunction aStarBi(graph, options) {\n  options = options || {};\n  // whether traversal should be considered over oriented graph.\n  var oriented = options.oriented;\n  var heuristic = options.heuristic;\n  if (!heuristic) heuristic = defaultSettings.heuristic;\n  var distance = options.distance;\n  if (!distance) distance = defaultSettings.distance;\n  var pool = makeSearchStatePool();\n  return {\n    find: find\n  };\n  function find(fromId, toId) {\n    // Not sure if we should return NO_PATH or throw. Throw seem to be more\n    // helpful to debug errors. So, throwing.\n    var from = graph.getNode(fromId);\n    if (!from) throw new Error('fromId is not defined in this graph: ' + fromId);\n    var to = graph.getNode(toId);\n    if (!to) throw new Error('toId is not defined in this graph: ' + toId);\n    if (from === to) return [from]; // trivial case.\n\n    pool.reset();\n    var callVisitor = oriented ? orientedVisitor : nonOrientedVisitor;\n\n    // Maps nodeId to NodeSearchState.\n    var nodeState = new Map();\n    var openSetFrom = new NodeHeap({\n      compare: defaultSettings.compareFScore,\n      setNodeId: defaultSettings.setHeapIndex\n    });\n    var openSetTo = new NodeHeap({\n      compare: defaultSettings.compareFScore,\n      setNodeId: defaultSettings.setHeapIndex\n    });\n    var startNode = pool.createNewState(from);\n    nodeState.set(fromId, startNode);\n\n    // For the first node, fScore is completely heuristic.\n    startNode.fScore = heuristic(from, to);\n    // The cost of going from start to start is zero.\n    startNode.distanceToSource = 0;\n    openSetFrom.push(startNode);\n    startNode.open = BY_FROM;\n    var endNode = pool.createNewState(to);\n    endNode.fScore = heuristic(to, from);\n    endNode.distanceToSource = 0;\n    openSetTo.push(endNode);\n    endNode.open = BY_TO;\n\n    // Cost of the best solution found so far. Used for accurate termination\n    var lMin = Number.POSITIVE_INFINITY;\n    var minFrom;\n    var minTo;\n    var currentSet = openSetFrom;\n    var currentOpener = BY_FROM;\n    while (openSetFrom.length > 0 && openSetTo.length > 0) {\n      if (openSetFrom.length < openSetTo.length) {\n        // we pick a set with less elements\n        currentOpener = BY_FROM;\n        currentSet = openSetFrom;\n      } else {\n        currentOpener = BY_TO;\n        currentSet = openSetTo;\n      }\n      var current = currentSet.pop();\n\n      // no need to visit this node anymore\n      current.closed = true;\n      if (current.distanceToSource > lMin) continue;\n      graph.forEachLinkedNode(current.node.id, callVisitor);\n      if (minFrom && minTo) {\n        // This is not necessary the best path, but we are so greedy that we\n        // can't resist:\n        return reconstructBiDirectionalPath(minFrom, minTo);\n      }\n    }\n    return NO_PATH; // No path.\n\n    function nonOrientedVisitor(otherNode, link) {\n      return visitNode(otherNode, link, current);\n    }\n    function orientedVisitor(otherNode, link) {\n      // For oritned graphs we need to reverse graph, when traveling\n      // backwards. So, we use non-oriented ngraph's traversal, and \n      // filter link orientation here.\n      if (currentOpener === BY_FROM) {\n        if (link.fromId === current.node.id) return visitNode(otherNode, link, current);\n      } else if (currentOpener === BY_TO) {\n        if (link.toId === current.node.id) return visitNode(otherNode, link, current);\n      }\n    }\n    function canExit(currentNode) {\n      var opener = currentNode.open;\n      if (opener && opener !== currentOpener) {\n        return true;\n      }\n      return false;\n    }\n    function reconstructBiDirectionalPath(a, b) {\n      var pathOfNodes = [];\n      var aParent = a;\n      while (aParent) {\n        pathOfNodes.push(aParent.node);\n        aParent = aParent.parent;\n      }\n      var bParent = b;\n      while (bParent) {\n        pathOfNodes.unshift(bParent.node);\n        bParent = bParent.parent;\n      }\n      return pathOfNodes;\n    }\n    function visitNode(otherNode, link, cameFrom) {\n      var otherSearchState = nodeState.get(otherNode.id);\n      if (!otherSearchState) {\n        otherSearchState = pool.createNewState(otherNode);\n        nodeState.set(otherNode.id, otherSearchState);\n      }\n      if (otherSearchState.closed) {\n        // Already processed this node.\n        return;\n      }\n      if (canExit(otherSearchState, cameFrom)) {\n        // this node was opened by alternative opener. The sets intersect now,\n        // we found an optimal path, that goes through *this* node. However, there\n        // is no guarantee that this is the global optimal solution path.\n\n        var potentialLMin = otherSearchState.distanceToSource + cameFrom.distanceToSource;\n        if (potentialLMin < lMin) {\n          minFrom = otherSearchState;\n          minTo = cameFrom;\n          lMin = potentialLMin;\n        }\n        // we are done with this node.\n        return;\n      }\n      var tentativeDistance = cameFrom.distanceToSource + distance(otherSearchState.node, cameFrom.node, link);\n      if (tentativeDistance >= otherSearchState.distanceToSource) {\n        // This would only make our path longer. Ignore this route.\n        return;\n      }\n\n      // Choose target based on current working set:\n      var target = currentOpener === BY_FROM ? to : from;\n      var newFScore = tentativeDistance + heuristic(otherSearchState.node, target);\n      if (newFScore >= lMin) {\n        // this can't be optimal path, as we have already found a shorter path.\n        return;\n      }\n      otherSearchState.fScore = newFScore;\n      if (otherSearchState.open === 0) {\n        // Remember this node in the current set\n        currentSet.push(otherSearchState);\n        currentSet.updateItem(otherSearchState.heapIndex);\n        otherSearchState.open = currentOpener;\n      }\n\n      // bingo! we found shorter path:\n      otherSearchState.parent = cameFrom;\n      otherSearchState.distanceToSource = tentativeDistance;\n    }\n  }\n}","map":{"version":3,"names":["module","exports","aStarBi","NodeHeap","require","makeSearchStatePool","heuristics","defaultSettings","BY_FROM","BY_TO","NO_PATH","l2","l1","graph","options","oriented","heuristic","distance","pool","find","fromId","toId","from","getNode","Error","to","reset","callVisitor","orientedVisitor","nonOrientedVisitor","nodeState","Map","openSetFrom","compare","compareFScore","setNodeId","setHeapIndex","openSetTo","startNode","createNewState","set","fScore","distanceToSource","push","open","endNode","lMin","Number","POSITIVE_INFINITY","minFrom","minTo","currentSet","currentOpener","length","current","pop","closed","forEachLinkedNode","node","id","reconstructBiDirectionalPath","otherNode","link","visitNode","canExit","currentNode","opener","a","b","pathOfNodes","aParent","parent","bParent","unshift","cameFrom","otherSearchState","get","potentialLMin","tentativeDistance","target","newFScore","updateItem","heapIndex"],"sources":["/home/brandon/security/learning/defi/uniswapv3-src/uniswapv3-code/ui/node_modules/ngraph.path/a-star/a-greedy-star.js"],"sourcesContent":["/**\n * Performs suboptimal, greed A Star path finding.\n * This finder does not necessary finds the shortest path. The path\n * that it finds is very close to the shortest one. It is very fast though.\n */\nmodule.exports = aStarBi;\n\nvar NodeHeap = require('./NodeHeap');\nvar makeSearchStatePool = require('./makeSearchStatePool');\nvar heuristics = require('./heuristics');\nvar defaultSettings = require('./defaultSettings');\n\nvar BY_FROM = 1;\nvar BY_TO = 2;\nvar NO_PATH = defaultSettings.NO_PATH;\n\nmodule.exports.l2 = heuristics.l2;\nmodule.exports.l1 = heuristics.l1;\n\n/**\n * Creates a new instance of pathfinder. A pathfinder has just one method:\n * `find(fromId, toId)`, it may be extended in future.\n * \n * NOTE: Algorithm implemented in this code DOES NOT find optimal path.\n * Yet the path that it finds is always near optimal, and it finds it very fast.\n * \n * @param {ngraph.graph} graph instance. See https://github.com/anvaka/ngraph.graph\n * \n * @param {Object} options that configures search\n * @param {Function(a, b)} options.heuristic - a function that returns estimated distance between\n * nodes `a` and `b`.  Defaults function returns 0, which makes this search equivalent to Dijkstra search.\n * @param {Function(a, b)} options.distance - a function that returns actual distance between two\n * nodes `a` and `b`. By default this is set to return graph-theoretical distance (always 1);\n * @param {Boolean} options.oriented - whether graph should be considered oriented or not.\n * \n * @returns {Object} A pathfinder with single method `find()`.\n */\nfunction aStarBi(graph, options) {\n  options = options || {};\n  // whether traversal should be considered over oriented graph.\n  var oriented = options.oriented;\n\n  var heuristic = options.heuristic;\n  if (!heuristic) heuristic = defaultSettings.heuristic;\n\n  var distance = options.distance;\n  if (!distance) distance = defaultSettings.distance;\n  var pool = makeSearchStatePool();\n\n  return {\n    find: find\n  };\n\n  function find(fromId, toId) {\n    // Not sure if we should return NO_PATH or throw. Throw seem to be more\n    // helpful to debug errors. So, throwing.\n    var from = graph.getNode(fromId);\n    if (!from) throw new Error('fromId is not defined in this graph: ' + fromId);\n    var to = graph.getNode(toId);\n    if (!to) throw new Error('toId is not defined in this graph: ' + toId);\n\n    if (from === to) return [from]; // trivial case.\n\n    pool.reset();\n\n    var callVisitor = oriented ? orientedVisitor : nonOrientedVisitor;\n\n    // Maps nodeId to NodeSearchState.\n    var nodeState = new Map();\n\n    var openSetFrom = new NodeHeap({\n      compare: defaultSettings.compareFScore,\n      setNodeId: defaultSettings.setHeapIndex\n    });\n\n    var openSetTo = new NodeHeap({\n      compare: defaultSettings.compareFScore,\n      setNodeId: defaultSettings.setHeapIndex\n    });\n\n\n    var startNode = pool.createNewState(from);\n    nodeState.set(fromId, startNode);\n\n    // For the first node, fScore is completely heuristic.\n    startNode.fScore = heuristic(from, to);\n    // The cost of going from start to start is zero.\n    startNode.distanceToSource = 0;\n    openSetFrom.push(startNode);\n    startNode.open = BY_FROM;\n\n    var endNode = pool.createNewState(to);\n    endNode.fScore = heuristic(to, from);\n    endNode.distanceToSource = 0;\n    openSetTo.push(endNode);\n    endNode.open = BY_TO;\n\n    // Cost of the best solution found so far. Used for accurate termination\n    var lMin = Number.POSITIVE_INFINITY;\n    var minFrom;\n    var minTo;\n\n    var currentSet = openSetFrom;\n    var currentOpener = BY_FROM;\n\n    while (openSetFrom.length > 0 && openSetTo.length > 0) {\n      if (openSetFrom.length < openSetTo.length) {\n        // we pick a set with less elements\n        currentOpener = BY_FROM;\n        currentSet = openSetFrom;\n      } else {\n        currentOpener = BY_TO;\n        currentSet = openSetTo;\n      }\n\n      var current = currentSet.pop();\n\n      // no need to visit this node anymore\n      current.closed = true;\n\n      if (current.distanceToSource > lMin) continue;\n\n      graph.forEachLinkedNode(current.node.id, callVisitor);\n\n      if (minFrom && minTo) {\n        // This is not necessary the best path, but we are so greedy that we\n        // can't resist:\n        return reconstructBiDirectionalPath(minFrom, minTo);\n      }\n    }\n\n    return NO_PATH; // No path.\n\n    function nonOrientedVisitor(otherNode, link) {\n      return visitNode(otherNode, link, current);\n    }\n\n    function orientedVisitor(otherNode, link) {\n      // For oritned graphs we need to reverse graph, when traveling\n      // backwards. So, we use non-oriented ngraph's traversal, and \n      // filter link orientation here.\n      if (currentOpener === BY_FROM) {\n        if (link.fromId === current.node.id) return visitNode(otherNode, link, current)\n      } else if (currentOpener === BY_TO) {\n        if (link.toId === current.node.id) return visitNode(otherNode, link, current);\n      }\n    }\n\n    function canExit(currentNode) {\n      var opener = currentNode.open\n      if (opener && opener !== currentOpener) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function reconstructBiDirectionalPath(a, b) {\n      var pathOfNodes = [];\n      var aParent = a;\n      while(aParent) {\n        pathOfNodes.push(aParent.node);\n        aParent = aParent.parent;\n      }\n      var bParent = b;\n      while (bParent) {\n        pathOfNodes.unshift(bParent.node);\n        bParent = bParent.parent\n      }\n      return pathOfNodes;\n    }\n\n    function visitNode(otherNode, link, cameFrom) {\n      var otherSearchState = nodeState.get(otherNode.id);\n      if (!otherSearchState) {\n        otherSearchState = pool.createNewState(otherNode);\n        nodeState.set(otherNode.id, otherSearchState);\n      }\n\n      if (otherSearchState.closed) {\n        // Already processed this node.\n        return;\n      }\n\n      if (canExit(otherSearchState, cameFrom)) {\n        // this node was opened by alternative opener. The sets intersect now,\n        // we found an optimal path, that goes through *this* node. However, there\n        // is no guarantee that this is the global optimal solution path.\n\n        var potentialLMin = otherSearchState.distanceToSource + cameFrom.distanceToSource;\n        if (potentialLMin < lMin) {\n          minFrom = otherSearchState;\n          minTo = cameFrom\n          lMin = potentialLMin;\n        }\n        // we are done with this node.\n        return;\n      }\n\n      var tentativeDistance = cameFrom.distanceToSource + distance(otherSearchState.node, cameFrom.node, link);\n\n      if (tentativeDistance >= otherSearchState.distanceToSource) {\n        // This would only make our path longer. Ignore this route.\n        return;\n      }\n\n      // Choose target based on current working set:\n      var target = (currentOpener === BY_FROM) ? to : from;\n      var newFScore = tentativeDistance + heuristic(otherSearchState.node, target);\n      if (newFScore >= lMin) {\n        // this can't be optimal path, as we have already found a shorter path.\n        return;\n      }\n      otherSearchState.fScore = newFScore;\n\n      if (otherSearchState.open === 0) {\n        // Remember this node in the current set\n        currentSet.push(otherSearchState);\n        currentSet.updateItem(otherSearchState.heapIndex);\n\n        otherSearchState.open = currentOpener;\n      }\n\n      // bingo! we found shorter path:\n      otherSearchState.parent = cameFrom;\n      otherSearchState.distanceToSource = tentativeDistance;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}